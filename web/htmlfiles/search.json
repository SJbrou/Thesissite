[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Thesis",
    "section": "",
    "text": "Here I’ll provide all the data for my thesis. Hosting it makes it easy to show the analysises that I do. Code is provided in the code, and also hosted complementary on github.\nFirst drafts of my thesis, presentation, collected data and scripts will be available here.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Home</span>"
    ]
  },
  {
    "objectID": "LoadXsense.html",
    "href": "LoadXsense.html",
    "title": "LoadXsense",
    "section": "",
    "text": "This is my R code and output of the Xsense Dot IMU data. The source code can be found on my github\n\n\nIMU’s do not start or stop measuring at the exact same moment in time. Thus, the amount of registration per IMU dffered (FreeAcc_X was of differing length). Assuming that the time in SampletimeFine is synchronized, I temporally realigned the data, excluding some of the first or last elements to ensure dataframes are of the same length\n\n\nCode for loading the data\n\n\n# Clean workspace and load dependencies\nrm(list = ls())\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(lubridate)\n\n# Function to load Xsense data (and convert time to seconds)\nLoadXsenseData &lt;- function(directory) {\n  files &lt;- list.files(path = directory, full.names = TRUE)  # Searches each marker file\n  data_list &lt;- lapply(files, function(file) { # creates a list storing the data\n    data &lt;- read.csv(file, header = TRUE, skip = 10) # reads each csv file\n    return(data)\n  })\n  names(data_list) &lt;- paste0(\"data\", seq_along(data_list))  # Names elements to my preference\n  \n  # Re-align time\n  min_time &lt;- min(sapply(data_list, function(df) min(df$SampleTimeFine))) #  Identify the minimum SampleTimeFine value across all data\n  adjusted_data_list &lt;- lapply(data_list, function(df) { # Subtract min_time from SampleTimeFine for each dataframe in data_list\n    df$SampleTimeFine &lt;- df$SampleTimeFine - min_time\n    df$A_abs &lt;- sqrt(df$FreeAcc_X^2 + df$FreeAcc_Y^2 + df$FreeAcc_Z^2)\n    df$TimeS &lt;- (df$SampleTimeFine / 1e6) - (df$SampleTimeFine[1] / 1e6) # Converts time to seconds\n    return(df)\n  })\n  \n  # Removing first elements of longer list, Find the minimum number of rows among all dataframes\n  min_rows &lt;- min(sapply(adjusted_data_list, nrow))\n  \n  # Remove elements from the beginning of each dataframe in adjusted_data_list\n  adjusted_data_list &lt;- lapply(adjusted_data_list, function(df) {\n    if (nrow(df) &gt; min_rows) {\n      df &lt;- df[(nrow(df) - min_rows + 1):nrow(df), , drop = FALSE]  # Remove elements from the beginning\n    }\n    return(df)\n  })\n  \n  # Define Markers dataframe\n  markers &lt;- data.frame(PacketCounter = adjusted_data_list[[1]]$PacketCounter,\n                        SampleTimeFine = adjusted_data_list[[1]]$SampleTimeFine,\n                        TimeS = adjusted_data_list[[1]]$TimeS)\n\n  # Add A_abs columns dynamically for each dataframe\n  for (i in 1:5) {\n    markers[paste0(\"A_abs\", i)] &lt;- adjusted_data_list[[i]]$A_abs\n  }\n\n  # Add FreeAcc_X, FreeAcc_Y, FreeAcc_Z columns for each dataframe\n  # for (i in 1:5) {\n  #   markers[paste0(\"A_X\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_X\n  #   markers[paste0(\"A_Y\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_Y\n  #   markers[paste0(\"A_Z\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_Z\n  # }\n\n  return(markers)  # Return the Markers dataframe\n}\n\n####################################################################\n#### function to load all different measurements into \"markers_list\"\nLoadMarkers &lt;- function(folderdir) {\n  markers &lt;- list()  # Initialize an empty list to store the dataframes\n  folders &lt;- list.dirs(folderdir, full.names = TRUE, recursive = FALSE)\n  for (i in seq_along(folders)) { # Iterate through each folder\n    data &lt;- LoadXsenseData(folders[i])  # Load Xsense data from the current folder\n    markers[[paste0(\"markers\", i)]] &lt;- data  # Store the dataframe in the list with a dynamic name\n  }\n  return(markers)  # Return the list of dataframes\n}\n\nmarkers_list &lt;- LoadMarkers(\"../../Logs\") # Load all data\n\n\n\nNormalise plots\nOnly the data during the lift should be considered. And I want to express time as percentage of the duration of an lift. Lets start by viewing the plot of the absolute acceleration of the barbell: Note that session 1 - 3 are test sessions.\n\n\n\n\n\n\nThe Y-axis scale differes. Note that for the strict press (session 4) the downward acceleration is almost similar to the upward acceleration. Thus, we are left with double the peaks in A_abs\nAlso, the difference between strict presses and push jerks becomes obvious when looking at upper leg acceleration:\n\n\n\n\n\n\n\n\n\n\nLetst exlude the data before and after the push jerk. This is the data I want to clip:\n\ncliptime &lt;- data.frame(\n  session = c(NA, NA, NA, NA, 5, 6, 7),\n  start = c(NA, NA, NA, NA, 8.4, 10.81, 8),\n  end = c(NA, NA, NA, NA, 27.35, 33.3, 38)\n)\n\n\n\nCode for clipping the data\n\n\n# plot to visually inspect all the data, to determine where to clip. Would like to program this so it automatically identifies the start of movement patterns. \nplot &lt;- plot_ly(markers_list[[5]], x = ~TimeS, y = ~A_abs5, type = 'scatter', mode = 'lines', name = \"Barbell\") %&gt;%\n  add_trace(y = ~A_abs3, name = \"Bovenbeen\") %&gt;%\n  layout(xaxis = list(title = \"TimeS\"), yaxis = list(title = \"A_abs\"), title = \"Strict Press\")\n# plot\nrm(plot)\n\n\nclip_data &lt;- function(cliptime, markers_list) {\n  sessions &lt;- list()\n  for (i in seq_along(markers_list)) {\n    session_num &lt;- i\n    if (!is.na(cliptime$session[session_num])) { # check if session should be clipped\n      filtered_df &lt;- markers_list[[i]] %&gt;%\n        filter(TimeS &gt;= cliptime$start[session_num] & TimeS &lt;= cliptime$end[session_num])\n      if (!is.null(filtered_df) && nrow(filtered_df) &gt; 0) {\n        assign(paste0(\"session\", session_num), filtered_df, envir = .GlobalEnv) \n        sessions[[paste0(\"session\", session_num)]] &lt;- filtered_df\n      }\n    }\n  }\n  return(sessions)\n}\n\n\nLets plot the clipped data.\n\n\n\n\n\n\nNow lets focus on only one lift\n\n# Create a list to store the plots\nplots &lt;- lapply(seq_along(sessions), function(i) {\n  # Plot Times against A_abs for the current dataframe\n  plot &lt;- plot_ly(sessions[[i]], x = ~TimeS, y = ~A_abs5, type = 'scatter', mode = 'lines', name = paste(\"session\", i+4)) %&gt;%\n  add_trace(y = ~A_abs2, name = \"Bovenbeen\", line = list(width = 1)) %&gt;%\n    layout(xaxis = list(title = \"TimeS\"), yaxis = list(title = \"A_abs\"))\n  return(plot)\n})\n\n# Combine plots into a single interactive plot\ncombined_plot &lt;- subplot(plots, nrows = length(plots))\ncombined_plot",
    "crumbs": [
      "Scripts",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>LoadXsense</span>"
    ]
  },
  {
    "objectID": "LoadXsense.html#correct-time",
    "href": "LoadXsense.html#correct-time",
    "title": "LoadXsense",
    "section": "",
    "text": "Code for loading the data\n\n\n# Clean workspace and load dependencies\nrm(list = ls())\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(lubridate)\n\n# Function to load Xsense data (and convert time to seconds)\nLoadXsenseData &lt;- function(directory) {\n  \n  \n  files &lt;- list.files(path = directory, full.names = TRUE)  # Searches each marker file\n  data_list &lt;- lapply(files, function(file) { # creates a list storing the data\n    data &lt;- read.csv(file, header = TRUE, skip = 10) # reads each csv file\n    return(data)\n  })\n  names(data_list) &lt;- paste0(\"data\", seq_along(data_list))  # Names elements to my preference\n  \n  ## Re-align time\n  min_time &lt;- min(sapply(data_list, function(df) min(df$SampleTimeFine))) #  Identify the minimum SampleTimeFine value across all data\n  adjusted_data_list &lt;- lapply(data_list, function(df) { # Subtract min_time from SampleTimeFine for each dataframe in data_list\n    df$SampleTimeFine &lt;- df$SampleTimeFine - min_time\n    df$A_abs &lt;- sqrt(df$FreeAcc_X^2 + df$FreeAcc_Y^2 + df$FreeAcc_Z^2)\n    df$TimeS &lt;- (df$SampleTimeFine / 1e6) - (df$SampleTimeFine[1] / 1e6) # Converts time to seconds\n    return(df)\n  })\n\n  # Removing first elements of longer list\n  # Find the minimum number of rows among all dataframes\n  min_rows &lt;- min(sapply(adjusted_data_list, nrow))\n\n  # Remove elements from the beginning of each dataframe in adjusted_data_list\n  adjusted_data_list &lt;- lapply(adjusted_data_list, function(df) {\n    if (nrow(df) &gt; min_rows) {\n      df &lt;- df[(nrow(df) - min_rows + 1):nrow(df), , drop = FALSE]  # Remove elements from the beginning\n    }\n    return(df)\n  })\n\n  # Define Markers dataframe\n  markers &lt;- data.frame(PacketCounter = adjusted_data_list[[1]]$PacketCounter,\n                        SampleTimeFine = adjusted_data_list[[1]]$SampleTimeFine,\n                        TimeS = adjusted_data_list[[1]]$TimeS)\n\n  # Add A_abs columns dynamically for each dataframe\n  for (i in 1:5) {\n    markers[paste0(\"A_abs\", i)] &lt;- adjusted_data_list[[i]]$A_abs\n  }\n\n  # Add FreeAcc_X, FreeAcc_Y, FreeAcc_Z columns for each dataframe\n  # for (i in 1:5) {\n  #   markers[paste0(\"A_X\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_X\n  #   markers[paste0(\"A_Y\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_Y\n  #   markers[paste0(\"A_Z\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_Z\n  # }\n\n  return(markers)  # Return the Markers dataframe\n}",
    "crumbs": [
      "Scripts",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>LoadXsense</span>"
    ]
  },
  {
    "objectID": "thesis.html",
    "href": "thesis.html",
    "title": "2  From push press to push jerk: does sex influence the movement pattern?",
    "section": "",
    "text": "2.1 Introduction\nThe ability to generate high power -the product of force and velocity- is essential for both daily activities and occupational tasks. It is widely acknowledged to be correlated with overall good health, and retaining power is considered a significant indicator of healthy ageing. Moreover, in the real of sports, power output is regarded as a strong determinant of athletic success. Consequently, the evaluation of muscular power and the development of training strategies aimed at enhancing power are of considerable interest to sport coaches, healthcare workers and researchers alike, and is reflected in the considerable attention focused on the development of power in athletes, and the research examining specific techniques used to maximize power development.\nExploratory investigations have delved into the power performances across various athletic disciplines, reporting Olympic weightlifting (OLY) as one of the disciplines where athletes demonstrated some of the highest absolute and relative peak power outputs. Consequently, OLY has been proposed as an effective means of enhancing peak power capacities. OLY involves lifting a loaded barbell off the ground to an overhead locked position, in either the Clean and Jerk (C&J) or Snatch, requiring high force in limited time to overcome gravity (5)\nThese assertions are supported by the biomechanical mechanics inherent to OLY exercises. Firstly, OLY exercises mimic sport-specific movements by engaging in forceful triple extension patterns involving the hips, knees and ankles. Secondly, they facilitate the generation of high rates of force development and power output.\nFurther justification for the inclusion of OLY exercises in training programs is provided by research highlighting correlations between OLY performance and various athletic attributes. Studies have shown significant associations between the hang power clean and sprinting (r = -0.58, p&lt;0.01), jumping (r=0.41, p &lt; 0.05) and change of direction tasks (r = -0.41, p &lt; 0.05). Additionally, a recent meta-analysis emphasis the efficacy of incorporating OLY exercises and their derivatives into training regimens, particularly in improving jumping performance compared to traditional resistance training, with a notable ~5% difference (effect size [ES] = 0.64, p &lt; 0.001) (Hackett et al., 2016).\nStudies have delved into the mechanics underlying these correlations. OLY exercises trigger hormonal responses similar to those observed following conventional strength and hypertrophy protocols. Additionally, cross-sectional data suggests that OLY training induces a transformation from type IIX to type-IIA muscle fibers, accompanied by hypertrophy specifically in type II fibers. This transfer confers advantages for maximal force production. As a result, weightlifters exhibit approximately 15-20% higher isometric peak force and a 13-16% faster contractile rate of force development compared to other strength and power athletes.\nFurthermore, OLY training has been found to reduce the typical sex-related gap in neuromuscular strength and power expression. However, this apparent sex-related difference seems to amplify with advancing adult age, revealing that women undergo a more pronounced age-related decline in muscle shortening velocity and peak power output when compared with men.\nNumerous studies have investigated the impact of sex on strength and other indices of musclular performance, consistently reporting lower levels of strength in females, even after accounting for confounding factors such as body weight. Some research has examined the relationship between shoulder strength and the Push Jerk (PJ), a movement where a barbell is propelled overhead, reporting differences in the ratio between the Strict Press and PJ across sexes. Generally there are three distinct manners of moving a barbell overhead: the Strict Press (SP), where exclusively the upper-limb strength is utilized to move the barbell; The Push Press (PP), involving a slight downward dip to engage the power of the triple extension; or the Push Jerk (PJ), allowing for catching the barbell at a lower position. Studies have indicated differences in the ratio between the SP and PJ across sexes. This has raised the question at what relative intensity movement patters transition from SP to PP, and form PP to PJ, and wether these thresholds differ between males and females. Given that males exhibit a higher SP-to-PJ ratio, it is hypothesized that female will transition to altered movement patterns at lower relative intensities.\nThe primary objective of this study is to investigate the relative intensities at which the movement pattern shifts from performing an overhead barbell press to push press, and from a push press to push jerk. Additionally, this study aims to assess the magnitude of these differences between male and female participants.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Thesis</span>"
    ]
  },
  {
    "objectID": "thesis.html#methods",
    "href": "thesis.html#methods",
    "title": "2  From push press to push jerk: does sex influence the movement pattern?",
    "section": "2.2 Methods",
    "text": "2.2 Methods\nA within-subject repeated measures research design was used to determine the kinetics of the S2O under different loads, and the corresponding shifts in preferred technique. IMU’s were placed on the right side of the barbell, lower arm, trunk, upper thighs and lower leg. Kinematic data was collected at [x Hz] and filtered with an [filter]\nParticipants were asked to press progressively loaded barbells overhead and instructed to SP as long as possible before switching to PP, and PP as long as possible before switching to PJ.\nDefining movements Technical aspects of the exercises have been well documented and defined elsewhere (19, 12). Differentiating visually can be error prone. Therefore, the movement performed is determined by the kinetics of the barbell, trunk, thighs and legs.\nStrict press Strict presses were defined as those movements where the barbell is pressed overhead in one upward motion, without any (prior) downward motion of the trunk or thighs. The lifter starts with the barbell in front-rack with their preferred grip width. The barbell should be presses overhead by extending the elbows and flexing the shoulders. The legs must not be involved. The lift is not disqualified if the barbell itself has downward motion at some point, as long as it eventually finishes overhead.\nPush press Generally the same set-up as in the strict press is used, but the movement starts with counter-movement: by dipping down and coming up the lifter can utilize the power of knee and hip extension, which generates additional upwards momentum. Push presses were defined as those movements where the barbell, trunk and possibly thighs have downward momentum proceeding the upward momentum.\nPush jerk Again, the same general set-up applies, but after accelerating the barbell upward, the athlete dips downward to catch the barbell in a lower position, thus requiring less upward momentum, and then stands up with the bar. PJ were defined as those movements where the momentum of the barbell, trunk or thighs starts downwards, and then reverses three times.\nTesting procedures Testing started with a warming-up protocol of two sets of 10 repetition of exercise specific drills: airsquats, front squats, SP, PP, PJ). After the warming up the participants were asked to rotate arround their vertical axis once to demarcate the starting of the testing in the IMU’s. Testing started with an empty 20kg barbell for the males, of 15kg barbell for the females, as is standard for olympic weightlifting. Participants were asked to press the barbell overhead, while retaining the SP and PP technique as long as possible. After each successful lift the barbell was loaded with an additional 5kg, unless the participants self-repoted an 1RM PJ of less then 80kg, in which case incremental steps of 2.5kg were used. Each participant was allowed reattempts, but testing stopped after more than two consecutive misses. Rest time between attempts was not allowed to exceed 2 minutes.\nStatistical analysis An a priori alpha level was set at p &lt;= 0.05.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Thesis</span>"
    ]
  },
  {
    "objectID": "LoadXsense.html#code",
    "href": "LoadXsense.html#code",
    "title": "LoadXsense",
    "section": "Code",
    "text": "Code\n\nCode for loading the data\n\n# Clean workspace and load dependencies\nrm(list = ls())\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(lubridate)\n\n# Function to load Xsense data (and convert time to seconds)\nLoadXsenseData &lt;- function(directory) {\n  \n  \n  files &lt;- list.files(path = directory, full.names = TRUE)  # Searches each marker file\n  data_list &lt;- lapply(files, function(file) { # creates a list storing the data\n    data &lt;- read.csv(file, header = TRUE, skip = 10) # reads each csv file\n    return(data)\n  })\n  names(data_list) &lt;- paste0(\"data\", seq_along(data_list))  # Names elements to my preference\n  \n  ## Re-align time\n  min_time &lt;- min(sapply(data_list, function(df) min(df$SampleTimeFine))) #  Identify the minimum SampleTimeFine value across all data\n  adjusted_data_list &lt;- lapply(data_list, function(df) { # Subtract min_time from SampleTimeFine for each dataframe in data_list\n    df$SampleTimeFine &lt;- df$SampleTimeFine - min_time\n    df$A_abs &lt;- sqrt(df$FreeAcc_X^2 + df$FreeAcc_Y^2 + df$FreeAcc_Z^2)\n    df$TimeS &lt;- (df$SampleTimeFine / 1e6) - (df$SampleTimeFine[1] / 1e6) # Converts time to seconds\n    return(df)\n  })\n\n  # Removing first elements of longer list\n  # Find the minimum number of rows among all dataframes\n  min_rows &lt;- min(sapply(adjusted_data_list, nrow))\n\n  # Remove elements from the beginning of each dataframe in adjusted_data_list\n  adjusted_data_list &lt;- lapply(adjusted_data_list, function(df) {\n    if (nrow(df) &gt; min_rows) {\n      df &lt;- df[(nrow(df) - min_rows + 1):nrow(df), , drop = FALSE]  # Remove elements from the beginning\n    }\n    return(df)\n  })\n\n  # Define Markers dataframe\n  markers &lt;- data.frame(PacketCounter = adjusted_data_list[[1]]$PacketCounter,\n                        SampleTimeFine = adjusted_data_list[[1]]$SampleTimeFine,\n                        TimeS = adjusted_data_list[[1]]$TimeS)\n\n  # Add A_abs columns dynamically for each dataframe\n  for (i in 1:5) {\n    markers[paste0(\"A_abs\", i)] &lt;- adjusted_data_list[[i]]$A_abs\n  }\n\n  # Add FreeAcc_X, FreeAcc_Y, FreeAcc_Z columns for each dataframe\n  # for (i in 1:5) {\n  #   markers[paste0(\"A_X\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_X\n  #   markers[paste0(\"A_Y\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_Y\n  #   markers[paste0(\"A_Z\", i)] &lt;- adjusted_data_list[[i]]$FreeAcc_Z\n  # }\n\n  return(markers)  # Return the Markers dataframe\n}\n\n\n\nLoadMarkers &lt;- function(folderdir) {\n  markers &lt;- list()  # Initialize an empty list to store the dataframes\n  folders &lt;- list.dirs(folderdir, full.names = TRUE, recursive = FALSE)\n  \n  for (i in seq_along(folders)) { # Iterate through each folder\n    data &lt;- LoadXsenseData(folders[i])  # Load Xsense data from the current folder\n    markers[[paste0(\"markers\", i)]] &lt;- data  # Store the dataframe in the list with a dynamic name\n  }\n  \n  return(markers)  # Return the list of dataframes\n}\n\nmarkers_list &lt;- LoadMarkers(\"../../Logs\")\n\n\nlibrary(plotly)\n\n# Create a list to store the plots\nplots &lt;- lapply(markers_list, function(marker) {\n  # Plot Times against A_abs for the current dataframe\n  plot &lt;- plot_ly(marker, x = ~TimeS, y = ~A_abs5, type = 'scatter', mode = 'lines') %&gt;%\n    layout(xaxis = list(title = \"TimeS\"), yaxis = list(title = \"A_abs\"))\n  \n  return(plot)\n})\n\n# Combine plots into a single interactive plot\ncombined_plot &lt;- subplot(plots, nrows = length(plots))\n\n# Print the combined plot\ncombined_plot",
    "crumbs": [
      "Scripts",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>LoadXsense</span>"
    ]
  }
]