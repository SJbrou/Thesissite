}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
adjusted_data_list <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(adjusted_data_list)) {
rows <- nrow(adjusted_data_list[[i]])
adjusted_data_list[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = adjusted_data_list[[1]]$TimeS,
A1 = adjusted_data_list[[1]]$A_abs,
A2 = adjusted_data_list[[2]]$A_abs,
A3 = adjusted_data_list[[3]]$A_abs,
A4 = adjusted_data_list[[4]]$A_abs,
A5 = adjusted_data_list[[5]]$A_abs,
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
return(toreturn)
}
# Some functions to visualise the acceleration and the Gyr
plot_a <- function(df) {
plot <- plot_ly(df, x = ~time, y = ~A1, name = "marker1", type = "scatter", mode = "lines") %>%
add_trace(y = ~A2, name = "marker 2") %>%
add_trace(y = ~A3, name = "marker 3") %>%
add_trace(y = ~A4, name = "marker 4") %>%
add_trace(y = ~A5, name = "marker 5") %>%
layout(title = "Measurement absolute accelerations",
xaxis = list(title = "Time"),
yaxis = list(title = "A Values"))
return(plot)
}
plot_gyr <- function(df) {
plot <- plot_ly(df, x = ~time, y = ~Gyr1, name = "marker1", type = "scatter", mode = "lines") %>%
add_trace(y = ~Gyr2, name = "marker 2") %>%
add_trace(y = ~Gyr3, name = "marker 3") %>%
add_trace(y = ~Gyr4, name = "marker 4") %>%
add_trace(y = ~Gyr5, name = "marker 5") %>%
layout(title = "Measurement absolute Gyr",
xaxis = list(title = "Time"),
yaxis = list(title = "Gyr Values"))
return(plot)
}
# Lets load it!
# loading the data
data1 <- LoadXsenseData("../../Logs/new/20240502_192335/", 60)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
}
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
adjusted_data_list <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(adjusted_data_list)) {
rows <- nrow(adjusted_data_list[[i]])
adjusted_data_list[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = adjusted_data_list[[1]]$TimeS,
A1 = adjusted_data_list[[1]]$A_abs,
A2 = adjusted_data_list[[2]]$A_abs,
A3 = adjusted_data_list[[3]]$A_abs,
A4 = adjusted_data_list[[4]]$A_abs,
A5 = adjusted_data_list[[5]]$A_abs,
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
}
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
adjusted_data_list <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(adjusted_data_list)) {
rows <- nrow(adjusted_data_list[[i]])
adjusted_data_list[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = adjusted_data_list[[1]]$TimeS,
A1 = adjusted_data_list[[1]]$A_abs,
A2 = adjusted_data_list[[2]]$A_abs,
A3 = adjusted_data_list[[3]]$A_abs,
A4 = adjusted_data_list[[4]]$A_abs,
A5 = adjusted_data_list[[5]]$A_abs,
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
View(data)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
}
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
data <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(data)) {
rows <- nrow(data[[i]])
data[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = data[[1]]$TimeS,
A1 = data[[1]]$A_abs,
A2 = data[[2]]$A_abs,
A3 = data[[3]]$A_abs,
A4 = data[[4]]$A_abs,
A5 = data[[5]]$A_abs,
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
data <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(data)) {
rows <- nrow(data[[i]])
data[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = data[[1]]$TimeS,
A1 = data[[1]]$A_abs,
A2 = data[[2]]$A_abs,
A3 = data[[3]]$A_abs,
A4 = data[[4]]$A_abs,
A5 = data[[5]]$A_abs,
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
#return(toreturn)
}
View(data)
View(toreturn)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
data <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(data)) {
rows <- nrow(data[[i]])
data[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = data[[1]]$TimeS,
A1 = ifelse("A_abs" %in% names(data[[1]]), data[[1]]$A_abs, NA),
A2 = ifelse("A_abs" %in% names(data[[2]]), data[[2]]$A_abs, NA),
A3 = ifelse("A_abs" %in% names(data[[3]]), data[[3]]$A_abs, NA),
A4 = ifelse("A_abs" %in% names(data[[4]]), data[[4]]$A_abs, NA),
A5 = ifelse("A_abs" %in% names(data[[5]]), data[[5]]$A_abs, NA),
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
#return(toreturn)
#}
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
data <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(data)) {
rows <- nrow(data[[i]])
data[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Return correct data
toreturn <- data.frame(
time = data[[1]]$TimeS,
A1 = ifelse("A_abs" %in% names(data[[1]]), data[[1]]$A_abs, NA),
A2 = ifelse("A_abs" %in% names(data[[2]]), data[[2]]$A_abs, NA),
A3 = ifelse("A_abs" %in% names(data[[3]]), data[[3]]$A_abs, NA),
A4 = ifelse("A_abs" %in% names(data[[4]]), data[[4]]$A_abs, NA),
A5 = ifelse("A_abs" %in% names(data[[5]]), data[[5]]$A_abs, NA),
Gyr1 = ifelse("Gyr_abs" %in% names(data[[1]]), data[[1]]$Gyr_abs, NA),
Gyr2 = ifelse("Gyr_abs" %in% names(data[[2]]), data[[2]]$Gyr_abs, NA),
Gyr3 = ifelse("Gyr_abs" %in% names(data[[3]]), data[[3]]$Gyr_abs, NA),
Gyr4 = ifelse("Gyr_abs" %in% names(data[[4]]), data[[4]]$Gyr_abs, NA),
Gyr5 = ifelse("Gyr_abs" %in% names(data[[5]]), data[[5]]$Gyr_abs, NA)
)
#return(toreturn)
#}
View(data)
View(toreturn)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
# Function to convert quaternions to Euler angles
quaternions_to_euler <- function(quat) {
roll  <- atan2(2*(quat$Quat_W*quat$Quat_X + quat$Quat_Y*quat$Quat_Z), 1 - 2*(quat$Quat_X^2 + quat$Quat_Y^2))
pitch <- asin(2*(quat$Quat_W*quat$Quat_Y - quat$Quat_Z*quat$Quat_X))
yaw   <- atan2(2*(quat$Quat_W*quat$Quat_Z + quat$Quat_X*quat$Quat_Y), 1 - 2*(quat$Quat_Y^2 + quat$Quat_Z^2))
return(data.frame(roll = roll, pitch = pitch, yaw = yaw))
}
# Function to differentiate Euler angles to obtain angular velocities
differentiate_euler_to_angular_velocity <- function(euler, time) {
roll_diff  <- diff(euler$roll) / diff(time)
pitch_diff <- diff(euler$pitch) / diff(time)
yaw_diff   <- diff(euler$yaw) / diff(time)
return(data.frame(roll = roll_diff, pitch = pitch_diff, yaw = yaw_diff))
}
# Function to differentiate angular velocities to obtain angular accelerations
differentiate_angular_velocity_to_acceleration <- function(angular_velocity, time) {
roll_diff  <- diff(angular_velocity$roll) / diff(time)
pitch_diff <- diff(angular_velocity$pitch) / diff(time)
yaw_diff   <- diff(angular_velocity$yaw) / diff(time)
return(data.frame(roll = roll_diff, pitch = pitch_diff, yaw = yaw_diff))
}
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
data <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(data)) {
rows <- nrow(data[[i]])
data[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Calculate angular acceleration for each dataframe
if ("Quat_W" %in% names(data[[i]])) {
for (i in seq_along(data)) {
euler_angles <- quaternions_to_euler(data[[i]])
angular_velocity <- differentiate_euler_to_angular_velocity(euler_angles, data[[i]]$TimeS)
angular_acceleration <- differentiate_angular_velocity_to_acceleration(angular_velocity, data[[i]]$TimeS)
data[[i]]$Angular_acc <- sqrt(angular_acceleration$roll^2 + angular_acceleration$pitch^2 + angular_acceleration$yaw^2)
}
}
View(euler_angles)
# Clean workspace and load dependencies
rm(list = ls())
library(tidyr)
library(dplyr)
library(plotly)
library(ggplot2)
library(knitr)
library(lubridate)
# Function to convert quaternions to Euler angles
quaternions_to_euler <- function(quat) {
roll  <- atan2(2*(quat$Quat_W*quat$Quat_X + quat$Quat_Y*quat$Quat_Z), 1 - 2*(quat$Quat_X^2 + quat$Quat_Y^2))
pitch <- asin(2*(quat$Quat_W*quat$Quat_Y - quat$Quat_Z*quat$Quat_X))
yaw   <- atan2(2*(quat$Quat_W*quat$Quat_Z + quat$Quat_X*quat$Quat_Y), 1 - 2*(quat$Quat_Y^2 + quat$Quat_Z^2))
return(data.frame(roll = roll, pitch = pitch, yaw = yaw))
}
# Function to differentiate Euler angles to obtain angular velocities
differentiate_euler_to_angular_velocity <- function(euler, time) {
roll_diff  <- diff(euler$roll) / diff(time)
pitch_diff <- diff(euler$pitch) / diff(time)
yaw_diff   <- diff(euler$yaw) / diff(time)
return(data.frame(roll = roll_diff, pitch = pitch_diff, yaw = yaw_diff))
}
# Function to differentiate angular velocities to obtain angular accelerations
differentiate_angular_velocity_to_acceleration <- function(angular_velocity, time) {
roll_diff  <- diff(angular_velocity$roll) / diff(time)
pitch_diff <- diff(angular_velocity$pitch) / diff(time)
yaw_diff   <- diff(angular_velocity$yaw) / diff(time)
return(data.frame(roll = roll_diff, pitch = pitch_diff, yaw = yaw_diff))
}
#LoadXsenseData <- function(directory, hz = 60) {
directory <- "../../Logs/new/20240502_192335/"
hz <- 60
files <- list.files(path = directory, full.names = TRUE)
data <- list()
# Read CSV files and calculate A_abs and Gyr_abs for each dataframe
for (i in seq_along(files)) {
data[[i]] <- read.csv(files[i], header = TRUE, skip = 10)
if ("FreeAcc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$FreeAcc_X^2 + data[[i]]$FreeAcc_Y^2 + data[[i]]$FreeAcc_Z^2) # calculate A_abs
}
if ("Acc_X" %in% names(data[[i]])) {
data[[i]]$A_abs <- sqrt(data[[i]]$Acc_X^2 + data[[i]]$Acc_Y^2 + data[[i]]$Acc_Z^2) # calculate A_abs
}
if ("Gyr_X" %in% names(data[[i]])) {
data[[i]]$Gyr_abs <- sqrt(data[[i]]$Gyr_X^2 + data[[i]]$Gyr_Y^2 + data[[i]]$Gyr_Z^2) # calculate Gyr_abs
}
}
# Ensure all dataframes have the same number of rows
min_rows <- min(sapply(data, nrow))
data <- lapply(data, function(df) {
df <- df[1:min_rows, , drop = FALSE]
return(df)
})
# Adjust time
for (i in seq_along(data)) {
rows <- nrow(data[[i]])
data[[i]]$TimeS <- ((1/hz) * (1:rows))
}
# Calculate angular acceleration for each dataframe
if ("Quat_W" %in% names(data[[i]])) {
for (i in seq_along(data)) {
euler_angles <- quaternions_to_euler(data[[i]])
angular_velocity <- differentiate_euler_to_angular_velocity(euler_angles, data[[i]]$TimeS)
angular_acceleration <- differentiate_angular_velocity_to_acceleration(angular_velocity, data[[i]]$TimeS)
data[[i]]$Angular_acc <- sqrt(angular_acceleration$roll^2 + angular_acceleration$pitch^2 + angular_acceleration$yaw^2)
}
}
